import json
import numpy as np
import time
import os
import datetime
from discretize import utils, CylMesh
import properties
import casingSimulations


def load_properties(filename):
    """
    Open a json file and load the properties into the target class

    As long as there are no namespace conflicts, the target __class__
    will be stored on the properties.HasProperties registry and may be
    fetched from there.

    :param str filename: name of file to read in
    """
    with open(filename, 'r') as outfile:
        jsondict = json.load(outfile)
        data = properties.HasProperties.deserialize(jsondict, trusted=True)
    return data


# grab 2D slices
def face3DthetaSlice(mesh3D, j3D, theta_ind=0):
    """
    Grab a theta slice through a 3D field defined on faces
    (x, z components), consistent with what would be found from a
    2D simulation

    :param discretize.CylMesh mesh3D: 3D cyl mesh
    :param numpy.ndarray j3D: vector of fluxes on mesh
    :param int theta_ind: index of the theta slice that you want
    """
    if mesh3D.isSymmetric:
        return j3D

    j3D_x = j3D[:mesh3D.nFx].reshape(mesh3D.vnFx, order='F')
    j3D_z = j3D[sum(mesh3D.vnF[:2]):].reshape(mesh3D.vnFz, order='F')

    j3Dslice = np.vstack([
        utils.mkvc(j3D_x[:, theta_ind, :], 2),
        utils.mkvc(j3D_z[:, theta_ind, :], 2)
    ])

    return j3Dslice


def edge3DthetaSlice(mesh3D, h3D, theta_ind=0):
    """
    Grab a theta slice through a 3D field defined on edges
    (y component), consistent with what would be found from a
    2D simulation

    :param discretize.CylMesh mesh3D: 3D cyl mesh
    :param numpy.ndarray h3D: vector of fields on mesh
    :param int theta_ind: index of the theta slice that you want
    """

    h3D_y = h3D[mesh3D.nEx:sum(mesh3D.vnE[:2])].reshape(
        mesh3D.vnEy, order='F'
    )

    return utils.mkvc(h3D_y[:, theta_ind, :])


def ccv3DthetaSlice(mesh3D, v3D, theta_ind=0):
    """
    Grab a theta slice through a 3D field defined at cell centers

    :param discretize.CylMesh mesh3D: 3D cyl mesh
    :param numpy.ndarray v3D: vector of fields on mesh
    :param int theta_ind: index of the theta slice that you want
    """

    ccv_x = v3D[:mesh3D.nC].reshape(mesh3D.vnC, order='F')
    ccv_y = v3D[mesh3D.nC:2*mesh3D.nC].reshape(mesh3D.vnC, order='F')
    ccv_z = v3D[2*mesh3D.nC:].reshape(mesh3D.vnC, order='F')

    return np.vstack([
        utils.mkvc(ccv_x[:, theta_ind, :], 2),
        utils.mkvc(ccv_y[:, theta_ind, :], 2),
        utils.mkvc(ccv_z[:, theta_ind, :], 2)
    ])

def mesh2d_from_3d(mesh):
        """
        create cylindrically symmetric mesh generator
        """
        mesh2D = CylMesh(
            [mesh.hx, 1., mesh.hz], x0=mesh.x0
        )
        return mesh2D

def writeSimulationPy(
    modelParameters='ModelParameters.json',
    meshGenerator='MeshParameters.json',
    src='Source.json',
    physics='FDEM',
    fields_filename='fields.npy',
    directory='.',
    simulation_filename='simulation.py',
    includeDC=True,  # cheap, why not
    include2D=True  # cheap, why not
):

    sim_file = '/'.join([directory, simulation_filename])
    with open(sim_file, 'w') as f:

        # add comment stating when the file was generated
        f.write(
            "# Autogenerated at {date} on version {version}\n".format(
                date=datetime.datetime.now().isoformat(),
                version=casingSimulations.__version__
            )
        )

        # write the imports
        f.write(
            "import casingSimulations\nimport numpy as np\n"
        )

        # write the simulation
        f.write(
            """
# Set up the simulation
sim = casingSimulations.run.Simulation{physics}(
    modelParameters='{modelParameters}',
    meshGenerator='{meshGenerator}',
    src='{src}',
    fields_filename='{fields_filename}'
)
\n""".format(
                physics=physics,
                modelParameters=modelParameters,
                meshGenerator=meshGenerator,
                src=src,
                fields_filename=fields_filename
            )
        )

        # write the run
        f.write(
            "# run the simulation \nfields = sim.run()\n"
        )

        # if we are including a 2D simulation
        if include2D:
            f.write(
                """
# Set up a 2D simulation for the same source location
mesh2D = sim.meshGenerator.copy()
mesh2D.hy = np.r_[2*np.pi]
src2D = getattr(casingSimulations.sources, sim.src.__class__.__name__)(
    modelParameters=sim.modelParameters,
    meshGenerator=mesh2D,
)
sim2D = casingSimulations.run.Simulation{physics}(
    modelParameters=sim.modelParameters,
    meshGenerator=mesh2D,
    src=src2D,
    fields_filename='fields2D.npy',
    filename='simulation2D.json'
)
\n""".format(
                    physics=physics,
                )
            )

        # run the 2D simulation
            f.write(
                "# run the 2D simulation \nfields2D = sim2D.run()\n"
            )

        # if we are including a DC simulation
        if includeDC:
            f.write(
                """
# Set up DC survey for the same source location
csz = sim.meshGenerator.csz
# make sure it is in the cell
src_a = sim.src.src_a_closest - np.r_[0., 0., csz/2.]
src_b = sim.src.src_b_closest - np.r_[0., 0., csz/2.]

simDC = casingSimulations.run.SimulationDC(
    filename='simulationDC.json',
    modelParameters=sim.modelParameters,
    meshGenerator=sim.meshGenerator,
    src_a=src_a,
    src_b=src_b
)\n"""
            )

            f.write(
                "# run the DC simulation \nfieldsDC = simDC.run()\n"
                )

    print('wrote {}'.format(sim_file))


def loadSimulationResults(
    directory=".",
    simulationParameters="simulationParameters.json",
    fields="fields.npy",
    meshGenerator=None
):
    print("Loading simulation in {}".format(directory))

    # load and populate the simulation
    simulation = load_properties(
        os.path.sep.join([directory, "simulationParameters.json"]),
    )

    simulation.prob.model = simulation.physprops.model

    # load up the numpy array of the soln
    print("   loading fields")
    field = np.load(os.path.sep.join([directory, fields]))

    if meshGenerator is None:
        meshGenerator = simulation.meshGenerator

    print("  repopulating fields")
    t = time.time()
    # fields = simulation.prob.fieldsPair(
    #     simulation.meshGenerator.mesh, simulation.survey
    # )

    if isinstance(
        simulation,
        (
            casingSimulations.run.SimulationFDEM,
            casingSimulations.run.SimulationDC
        )
    ):
        simulation._fields = simulation.prob.fieldsPair(
            meshGenerator.mesh, simulation.survey
        )[
            :, '{}Solution'.format(simulation.formulation)
        ]
    elif isinstance(simulation, casingSimulations.run.SimulationTDEM):
        simulation._fields = simulation.prob.fieldsPair(
            meshGenerator.mesh, simulation.survey
        )[
            :, :, '{}Solution'.format(simulation.formulation)
        ]

    print('   ... Done. Elapsed time : {}\n'.format(time.time()-t))

    return simulation
